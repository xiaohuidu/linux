
In the Linux kernel, signals are a mechanism used to communicate asynchronously with processes. Signals are typically generated by user-space programs, other processes, or the kernel itself and are then delivered to target processes. Hereâ€™s a detailed breakdown of how signals are generated, delivered, and handled in the Linux kernel:

----------
### **1. Realtime and Non-Realtime signals**

In the context of Linux signals, **real-time signals** and **non-real-time signals** refer to two categories of signals with different behavior and use cases. Both types are mechanisms for asynchronous communication between processes or between a process and the kernel.

**1. Non-Real-Time Signals**

These are the traditional signals defined by the POSIX standard. Examples include `SIGTERM`, `SIGKILL`, `SIGINT`, `SIGSEGV`, etc.

#### **Characteristics**:

1.  **Limited Set of Signals**:    
    -   There are 31 standard signals (`1` to `31` in most systems).
    -   These are defined as constants in `<signal.h>`.
2.  **Fixed Behavior**:    
    -   Each signal has a specific, predefined purpose (e.g., `SIGKILL` to terminate a process, `SIGINT` for user interruption).
3.  **Non-Queued**:    
    -   Only one instance of a signal can be pending at any time.
    -   If the same signal is sent multiple times before the process handles it, the process will receive it only once.
4.  **Delivery Order**:    
    -   The delivery order is not guaranteed if multiple signals are sent to a process.
5.  **No Data**:    
    -   Signals do not carry additional data; only the signal number is delivered.

**Examples**:

-   **`SIGTERM`**: Request to terminate the process (can be caught or ignored).
-   **`SIGKILL`**: Forcefully kill the process (cannot be caught or ignored).
-   **`SIGSEGV`**: Sent when a segmentation fault occurs.


**2. Real-Time Signals**

Real-time signals are an extension of the standard signal mechanism introduced by the POSIX real-time extensions. They provide enhanced functionality compared to non-real-time signals.

#### **Characteristics**:

1.  **Extended Range**:    
    -   Signal numbers for real-time signals are typically from `SIGRTMIN` to `SIGRTMAX`.
    -   The actual range depends on the system but is usually around 32 real-time signals.
2.  **Queuing Support**:    
    -   Real-time signals can queue multiple instances.
    -   Each signal in the queue is delivered exactly once, even if the same signal is sent multiple times.
3.  **Delivery Order**:    
    -   Signals are delivered in the order they were sent, ensuring predictable behavior.
4.  **Data Payload**:    
    -   Real-time signals can carry additional user-defined data (`sigval`).
    -   This is possible with functions like `sigqueue()`.
5.  **Higher Priority**:    
    -   Real-time signals have higher priority than non-real-time signals.

**Examples**:
-   Real-time signals are often used in advanced inter-process communication (IPC) scenarios.

The range of real-time signals (`SIGRTMIN` to `SIGRTMAX`) can vary between systems and is defined in `<signal.h>`. You can inspect the values on a Linux system with:
```
cat /proc/sys/kernel/rtsig-max
```

----------

### **2. Signal Generation**

Signals can be generated in several ways:

-   **System Calls**: Signals are commonly generated using system calls such as:
    
    -   `kill()`: Sends a signal to a specific process or process group.
    
    <details>
    
    ```c
    struct 
    {                                
        int si_signo;                   
        int si_code;                    
        int si_errno;                   
        union __sifields _sifields;     
    }

    typedef struct kernel_siginfo 
    {
        __SIGINFO;
    } kernel_siginfo_t;
    // pid: the PID fo the process
    // sig: signal to be sent
    SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)
    {
	    struct kernel_siginfo info;
	    prepare_kill_siginfo(sig, &info, PIDTYPE_TGID);
	    return kill_something_info(sig, &info, pid);
    }
    
    static void prepare_kill_siginfo(int sig, struct kernel_siginfo *info,
                                 enum pid_type type)
    {  
        clear_siginfo(info);
        info->si_signo = sig;
        info->si_errno = 0;
        info->si_code = (type == PIDTYPE_PID) ? SI_TKILL : SI_USER;
        info->si_pid = task_tgid_vnr(current);
        info->si_uid = from_kuid_munged(current_user_ns(), 	current_uid());
    }

	// Send signal to a process.
    static int kill_something_info(int sig, struct kernel_siginfo *info, pid_t pid)
    {
        int ret;

        if (pid > 0)
		        // If PID is specified > 0, call kill_proc_info
                return kill_proc_info(sig, info, pid);

        /* -INT_MIN is undefined.  Exclude this case to avoid a UBSAN warning */
        if (pid == INT_MIN)
                return -ESRCH;

        read_lock(&tasklist_lock);
        if (pid != -1) {
                ret = __kill_pgrp_info(sig, info,
                                pid ? find_vpid(-pid) : task_pgrp(current));
        } else {
                int retval = 0, count = 0;
                struct task_struct * p;

                for_each_process(p) {
                        if (task_pid_vnr(p) > 1 &&
                                        !same_thread_group(p, current)) {
                                int err = group_send_sig_info(sig, info, p,
                                                              PIDTYPE_MAX);
                                ++count;
                                if (err != -EPERM)
                                        retval = err;
                        }
                }
                ret = count ? retval : -ESRCH;
        }
        read_unlock(&tasklist_lock);

        return ret;
        }
    // Kill a process
    static int kill_proc_info(int sig, struct kernel_siginfo *info, pid_t pid)
    {
        int error;
        rcu_read_lock();
        error = kill_pid_info(sig, info, find_vpid(pid));
        rcu_read_unlock();
        return error;
    }
    int kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)
    {
        return kill_pid_info_type(sig, info, pid, PIDTYPE_TGID);
    }
    static int kill_pid_info_type(int sig, struct kernel_siginfo *info,
                                struct pid *pid, enum pid_type type)
    {
        int error = -ESRCH;
        struct task_struct *p;

        for (;;) {
                rcu_read_lock();
                p = pid_task(pid, PIDTYPE_PID); //Get the process data (struct task_struct)
                if (p)
                        error = group_send_sig_info(sig, info, p, type);
                rcu_read_unlock();
                if (likely(!p || error != -ESRCH))
                        return error;
                /*
                 * The task was unhashed in between, try again.  If it
                 * is dead, pid_task() will return NULL, if we race with
                 * de_thread() it will find the new leader.
                 */
        }
    }

	// Send a signal to a process.
    int group_send_sig_info(int sig, struct kernel_siginfo *info,
                        struct task_struct *p, enum pid_type type)
    {
        int ret;

        rcu_read_lock();
        ret = check_kill_permission(sig, info, p);
        rcu_read_unlock();

        if (!ret && sig)
                ret = do_send_sig_info(sig, info, p, type);

        return ret;
	}       

    int do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,
                        enum pid_type type)
    {
        unsigned long flags;
        int ret = -ESRCH;

        if (lock_task_sighand(p, &flags)) {
                ret = send_signal_locked(sig, info, p, type);
                unlock_task_sighand(p, &flags);
        }

        return ret;
    }

    int send_signal_locked(int sig, struct kernel_siginfo *info,
                       struct task_struct *t, enum pid_type type)
    {
        /* Should SIGKILL or SIGSTOP be received by a pid namespace init? */
        bool force = false;

        if (info == SEND_SIG_NOINFO) {
                /* Force if sent from an ancestor pid namespace */
                force = !task_pid_nr_ns(current, task_active_pid_ns(t));
        } else if (info == SEND_SIG_PRIV) {
                /* Don't ignore kernel generated signals */
                force = true;
        } else if (has_si_pid_and_uid(info)) {
                /* SIGKILL and SIGSTOP is special or has ids */
                struct user_namespace *t_user_ns;

                rcu_read_lock();
                t_user_ns = task_cred_xxx(t, user_ns);
                if (current_user_ns() != t_user_ns) {
                        kuid_t uid = make_kuid(current_user_ns(), info->si_uid);
                        info->si_uid = from_kuid_munged(t_user_ns, uid);
                }
                rcu_read_unlock();

                /* A kernel generated signal? */
                force = (info->si_code == SI_KERNEL);

                /* From an ancestor pid namespace? */
                if (!task_pid_nr_ns(current, task_active_pid_ns(t))) {
                        info->si_pid = 0;
                        force = true;
                }
        }
        return __send_signal_locked(sig, info, t, type, force);
    }

    static int __send_signal_locked(int sig, struct kernel_siginfo *info,
                                struct task_struct *t, enum pid_type type, bool force)
    {
        struct sigpending *pending;
        struct sigqueue *q;
        int override_rlimit;
        int ret = 0, result;

        lockdep_assert_held(&t->sighand->siglock);

        result = TRACE_SIGNAL_IGNORED;
        if (!prepare_signal(sig, t, force))
                goto ret;

        pending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;
        /*
         * Short-circuit ignored signals and support queuing
         * exactly one non-rt signal, so that we can get more
         * detailed information about the cause of the signal.
         */
        result = TRACE_SIGNAL_ALREADY_PENDING;
        if (legacy_queue(pending, sig))
                goto ret;

        result = TRACE_SIGNAL_DELIVERED;
        /*
         * Skip useless siginfo allocation for SIGKILL and kernel threads.
         */
        if ((sig == SIGKILL) || (t->flags & PF_KTHREAD))
                goto out_set;

        /*
         * Real-time signals must be queued if sent by sigqueue, or
         * some other real-time mechanism.  It is implementation
         * defined whether kill() does so.  We attempt to do so, on
         * the principle of least surprise, but since kill is not
         * allowed to fail with EAGAIN when low on memory we just
         * make sure at least one signal gets delivered and don't
         * pass on the info struct.
         */
        if (sig < SIGRTMIN)
                override_rlimit = (is_si_special(info) || info->si_code >= 0);
        else
                override_rlimit = 0;

        q = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, 0);

        if (q) {
                list_add_tail(&q->list, &pending->list);
                switch ((unsigned long) info) {
                case (unsigned long) SEND_SIG_NOINFO:
                        clear_siginfo(&q->info);
                        q->info.si_signo = sig;
                        q->info.si_errno = 0;
                        q->info.si_code = SI_USER;
                        q->info.si_pid = task_tgid_nr_ns(current,
                                                        task_active_pid_ns(t));
                        rcu_read_lock();
                        q->info.si_uid =
                                from_kuid_munged(task_cred_xxx(t, user_ns),
                                                 current_uid());
                        rcu_read_unlock();
                        break;
                case (unsigned long) SEND_SIG_PRIV:
                        clear_siginfo(&q->info);
                        q->info.si_signo = sig;
                        q->info.si_errno = 0;
                        q->info.si_code = SI_KERNEL;
                        q->info.si_pid = 0;
                        q->info.si_uid = 0;
                        break;
                default:
                        copy_siginfo(&q->info, info);
                        break;
                }
        } else if (!is_si_special(info) &&
                   sig >= SIGRTMIN && info->si_code != SI_USER) {
                /*
                 * Queue overflow, abort.  We may abort if the
                 * signal was rt and sent by user using something
                 * other than kill().
                 */
                result = TRACE_SIGNAL_OVERFLOW_FAIL;
                ret = -EAGAIN;
                goto ret;
        } else {
                /*
                 * This is a silent loss of information.  We still
                 * send the signal, but the *info bits are lost.
                 */
                result = TRACE_SIGNAL_LOSE_INFO;
        }
    out_set:
        signalfd_notify(t, sig);
        sigaddset(&pending->signal, sig);

        /* Let multiprocess signals appear after on-going forks */
        if (type > PIDTYPE_TGID) {
                struct multiprocess_signals *delayed;
                hlist_for_each_entry(delayed, &t->signal->multiprocess, node) {
                        sigset_t *signal = &delayed->signal;
                        /* Can't queue both a stop and a continue signal */
                        if (sig == SIGCONT)
                                sigdelsetmask(signal, SIG_KERNEL_STOP_MASK);
                        else if (sig_kernel_stop(sig))
                                sigdelset(signal, SIGCONT);
                        sigaddset(signal, sig);
                }
        }

        complete_signal(sig, t, type);
    ret:
        trace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);
        return ret;
    }
    ```
    </details>
    
    -   `raise()`: A process sends a signal to itself.
    
    <details>
    The raise() function is a standard C library function used to send a signal to  the calling process. It is part of the POSIX standard and is defined in the <signal.h> header. Hereâ€™s a detailed explanation of where raise() is defined and how it works:
    
    ```c
    int raise(int sig);
    ``` 
       
    The raise() function is typically implemented in the C standard library (e.g., glibc for Linux). It works by internally calling the system call interface for sending signals, such as kill() or tgkill().

    Here is a simplified example of how raise() might be implemented:

    ```c
    #include <signal.h>
    #include <unistd.h>
    #include <sys/types.h>
    int raise(int sig) {
        return kill(getpid(), sig);  // Sends the signal to the calling process
    }
    ```

    </details>
    
    -   `sigqueue()`: Sends a signal along with additional data (real-time signals).
    
    <details>
    The `sigqueue()` function is a POSIX-compliant system call that allows a process to send a signal to another process, along with an accompanying user-defined value. Unlike simpler signal-sending functions like `kill()`, `sigqueue()` provides additional functionality by allowing a signal to carry an extra data payload.
    The `sigqueue()` function is declared in `<signal.h>` as follows
    
    ```c
    int sigqueue(pid_t pid, int sig, const union sigval value);
    ```
    
    </details>
    
    -   `alarm()`, `setitimer()`: Generate a signal after a timer expires.
    
    <details>
    Both alarm() and setitimer() are functions for scheduling the delivery of signals after a specified period of time. They are used for implementing timeouts or periodic actions, but they differ significantly in flexibility and precision.
    alarm() schedules the delivery of a SIGALRM signal to the calling process after a specified number of seconds. It is a simple timer with limited functionality.
    prototype:
    
    ```c
    #include <unistd.h>
    unsigned int alarm(unsigned int seconds);
   ```
   
    </details>
    
-   **Hardware Events**: Signals can also be generated by hardware exceptions, such as:
    
    -   Division by zero or invalid memory access triggers signals like `SIGFPE` and `SIGSEGV`.
    -   Keyboard interrupts (e.g., Ctrl+C) generate `SIGINT`.
-   **Kernel Events**: Signals may be generated by the kernel itself in response to specific events, such as:
    
    -   Parent process exiting (`SIGCHLD` sent to a parent process when a child exits).
    -   Terminal hang-ups (`SIGHUP`).
    -   Timer expiration (`SIGALRM`).

----------

### **3. Signal Delivery**

Once a signal is generated, the kernel queues it for the target process. Delivery follows these steps:

#### **Data Structures**

-   Signals are stored in a process's `struct task_struct`, specifically in `struct signal_struct` and `struct sighand_struct`.
    -   `signal_struct`: Tracks signal-related state (shared by threads in a thread group).
    -   `sighand_struct`: Contains signal handlers and signal disposition for the process.
-   Pending signals are maintained in:
    -   `task_struct->pending`: For signals specific to a thread.
    -   `signal_struct->shared_pending`: For signals shared across a thread group.

#### **Signal Queuing**

-   Non-real-time signals: Only one instance of the signal is queued (overwrites any existing instance of the same signal).
-   Real-time signals: Multiple instances of the same signal can be queued, along with any accompanying data.

#### **Delivery Process**

1.  **Check for Eligibility**:
    
    -   The kernel checks the permissions of the sender process to ensure it can send the signal to the target process.
2.  **Queue the Signal**:
    
    -   The kernel places the signal in the appropriate signal queue (`pending` or `shared_pending`).
3.  **Wake Up Target**:
    
    -   If the target process is sleeping, the kernel wakes it up to handle the signal.

----------

### **4. Signal Handling**

When a process is scheduled to run, it checks for pending signals. If a signal is pending, it is processed as follows:

#### **Signal Dispositions**

A signal can have one of several dispositions:

-   **Default Action**: Defined by the signal type (e.g., terminate, ignore, dump core).
-   **Custom Handler**: A user-space function registered via `signal()` or `sigaction()`.
-   **Ignore**: The signal is discarded (e.g., `SIG_IGN`).
-   **Blocked**: The signal is held until it is unblocked.

#### **Process Execution Context**

-   If the process is in **user mode**, the kernel delivers the signal upon return to user space.
-   If the process is in **kernel mode**, signal delivery is deferred until the process returns to user mode.

#### **Signal Execution**

-   The kernel alters the process's state (e.g., its stack and instruction pointer) to invoke the appropriate signal handler or perform the default action.

----------

### **5. Key Kernel Functions**

-   **Signal Generation**:
    
    -   `send_sig_info()`: Sends a signal to a specific task.
    -   `kill_pid_info()`: Sends a signal to a process identified by PID.
    -   `group_send_sig_info()`: Sends a signal to a thread group.
-   **Signal Handling**:
    
    -   `get_signal()`: Checks for pending signals and determines which to deliver.
    -   `do_signal()`: Processes pending signals and invokes the handler or takes the default action.
    -   `force_sig()`: Forces the delivery of a signal, bypassing permission checks.

----------

### **6. Thread Groups and Signals**

In a multithreaded program:

-   Signals can be directed to a specific thread or the entire thread group.
-   Signals like `SIGKILL` and `SIGSTOP` are directed to all threads in a group.
-   Thread-local signals are handled individually by the specified thread.

----------

### **7. Real-Time Signals**

Real-time signals (`SIGRTMIN` to `SIGRTMAX`):

-   Have higher priority than standard signals.
-   Support queuing of multiple instances.
-   Allow passing additional data (e.g., pointers or integers) via `sigqueue()`.

----------

### **8. Default Signal Actions**

Each signal has a predefined default action:

-   **Terminate**: Process is terminated (e.g., `SIGTERM`).
-   **Terminate and Core Dump**: Process is terminated, and a core dump is generated (e.g., `SIGSEGV`).
-   **Ignore**: The signal is discarded (e.g., `SIGCHLD`).
-   **Stop**: Process execution is stopped (e.g., `SIGSTOP`).
-   **Continue**: Resumes a stopped process (e.g., `SIGCONT`).

----------

### **9. Signal Masking and Blocking**

Processes can block or mask signals using:

-   `sigprocmask()`: Modifies the signal mask of a process.
-   `pthread_sigmask()`: Used in multithreaded applications.

Blocked signals remain pending until they are unblocked.

----------

### **10. Example Workflow: `kill` Command**

1.  The `kill` command invokes the `kill()` system call to send a signal.
2.  The kernel checks permissions and identifies the target process.
3.  The kernel queues the signal in the process's signal queue.
4.  The target process is woken up if necessary.
5.  The process checks for pending signals and handles them accordingly.

----------

This overview captures the signal lifecycle in Linux, showcasing its flexibility and robustness in managing asynchronous events in a process-controlled environment.

4o

##### You said:

what is a thread group

###### ChatGPT said:

ChatGPT

In the Linux kernel, a **thread group** is a collection of threads that share certain resources and are treated as a unit in certain operations. Thread groups play a key role in process and thread management, particularly in multithreaded applications. Below are the details about thread groups:

----------

### **1. Thread Group Definition**

-   A **thread group** is a set of threads that share the same **process ID (PID)**.
-   The first thread in a thread group is called the **thread group leader**, and its PID serves as the **thread group ID (TGID)** for the entire group.
-   All other threads in the group have a unique **thread ID (TID)** but share the TGID of the thread group leader.

----------

### **2. Characteristics of Thread Groups**

1.  **Shared Resources**: Threads within a thread group share:
    
    -   **Memory Space**: The same address space (e.g., global variables, heap).
    -   **File Descriptors**: Access to open files.
    -   **Signal Handlers**: Shared disposition for signals.
    -   **File System Context**: Current working directory and root directory.
    -   **Process Credentials**: User and group IDs.
2.  **Separate Execution Contexts**: Each thread has:
    
    -   Its own **stack**.
    -   Independent **registers** (including the instruction pointer).
    -   Separate **signal masks** for blocking specific signals.
3.  **Unified PID Namespace**:
    
    -   From a user's perspective, a thread group appears as a single process (identified by the TGID).
    -   Internally, each thread has a unique kernel identifier (TID).

----------

### **3. Thread Group Lifecycle**

1.  **Creation**:
    
    -   A thread group is created when a new thread is spawned within a process using system calls like `clone()` or user-space libraries like `pthread_create()`.
    -   The `CLONE_THREAD` flag passed to `clone()` indicates that the new task is part of the same thread group.
2.  **Synchronization**:
    
    -   Threads in a group may synchronize with each other using mutexes, condition variables, or other primitives.
3.  **Termination**:
    
    -   When a thread group leader exits, it typically terminates the entire thread group (unless explicitly configured otherwise).
    -   A `SIGKILL` sent to the TGID affects all threads in the group.

----------

### **4. Thread Groups and Signals**

Signal handling in thread groups is a complex but crucial part of thread management:

1.  **Shared Signal Handling**:
    
    -   Signals sent to a thread group (using the TGID) can be handled by any thread in the group.
    -   Certain signals, like `SIGSTOP`, `SIGCONT`, and `SIGKILL`, affect the entire thread group.
2.  **Thread-Specific Signals**:
    
    -   Signals can be sent to a specific thread (using its TID). For example, `tgkill()` allows targeting an individual thread.
3.  **Default and Custom Behavior**:
    
    -   Default signal actions, like termination, may affect the entire group.
    -   Custom handlers can allow specific threads to process signals.

----------

### **5. Kernel Data Structures for Thread Groups**

1.  **`task_struct`**:
    
    -   Represents a single thread.
    -   Contains information about whether the thread is a group leader (`thread_group_leader`).
2.  **Linked Threads**:
    
    -   Threads in the same thread group are linked via a doubly linked list (`thread_group`).
3.  **`signal_struct`**:
    
    -   Shared by all threads in the group.
    -   Tracks signals that are pending for the group.

----------

### **6. Advantages of Thread Groups**

1.  **Efficiency**:
    
    -   Shared resources reduce overhead compared to separate processes.
    -   Threads can communicate efficiently by sharing memory.
2.  **POSIX Compliance**:
    
    -   Thread groups align with POSIX threading standards (e.g., `pthreads`).
3.  **Simplified Management**:
    
    -   Treating thread groups as single units simplifies operations like signal handling and scheduling.

----------

### **7. Example: Thread Group Operations**

-   **Thread Group Creation**:
    
    -   The main process creates a thread using `pthread_create()`, which results in a thread group in the kernel.
-   **Signal Handling**:
    
    -   A `SIGKILL` sent to the thread group (TGID) terminates all threads in the group.
-   **Iterating Over Threads**:
    
    -   The kernel uses the `thread_group` list to iterate over all threads in the group when performing group-wide operations.

----------

### **8. Example: `gettid()` vs `getpid()`**

1.  **`gettid()`**:
    
    -   Returns the TID of the calling thread (unique kernel identifier for each thread).
2.  **`getpid()`**:
    
    -   Returns the TGID of the calling thread (shared by all threads in the group).

For instance:

c

Copy code

`#include <unistd.h>
#include <sys/syscall.h>
#include <stdio.h>

int main() {
    printf("PID: %d\n", getpid());
    printf("TID: %ld\n", syscall(SYS_gettid));
    return 0;
}` 

If this code is executed in a multithreaded process, `getpid()` will return the same value for all threads, while `gettid()` will return unique values.

----------

### **Summary**

A thread group is essentially a set of threads that share the same resources and are managed collectively by the Linux kernel. It provides a foundation for implementing POSIX-compliant multithreading and allows efficient sharing of resources like memory, file descriptors, and signal handlers. Thread groups simplify the management of multithreaded applications while enabling fine-grained control over individual threads.
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE3MjUyODQ4NDQsLTc1Nzc1NjY2MCwtMT
EwMDM1MTc3MiwtMTkwNDkyOTA1OSwtNjI3OTEzNDE1LC0yMTE2
OTcyOTk0LC0xNjEyODcxMDMxLDkwNzc4OTk2NiwtMTExODQxND
IwNCw4ODAxMzM4NjYsLTMwNTE3MDY0NywxNjMxMzgzNDU2LC0x
ODU2MTMyOTk2LDExNTMyNTEzMzgsLTEzMzgwMDAwNDUsLTIyNj
kwMzExMSw5OTI0NDU5ODksLTMzMjQ1NTM2M119
-->